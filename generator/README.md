# Code Generation

The code generator reads and parse content of a `io.Reader` in order to find the events, fields and their types. The generated code would be stored in `events.go` file and is annotated by `// Code generated by go generate; DO NOT EDIT.`.

## List of generated items
An interface `Event` is defined to abstract the common functionalities that all event types should provide. Later in the `events.go`, the implementation of the interface for each event is generated. 

```go
type Event interface {

	// Store stores the single instance
	Store(ctx context.Context, db *sql.DB) error

	// Retrieve retrieves events from database filtered by start and the end time
	Retrieve(ctx context.Context, start, end int64, db *sql.DB) ([]Event, error)
}
```

### For each event

Each event found in the type_mappings file would be generated with field attached to it, with a name camel cased, for example `transfer_coins` becomes `TransferCoinsEvent`. Then the fields are added with appropriate type mapping and `gorm` tags for migrating the schemas (read more below), and `json` tag with the field name tag found in the type_mapping file. An example of a struct generated for a type mapping is presented below:
```json
  "burn_coins":{
     "type":"struct",
     "type_mapping":{
        "time":"timestamp",
        "amount":"bigint",
        "account_id":"int"
     }
  }
```
```go
// BurnCoinsEvent coresponds to the type burn_coins in the type_mappings
type BurnCoinsEvent struct {

	// generated based on time with type timestamp
	Time int64 `gorm:"int64,column:time,index" json:"time"`

	// generated based on amount with type bigint
	Amount int64 `gorm:"int64,column:amount" json:"amount"`

	// generated based on account_id with type int
	AccountId int `gorm:"int,column:account_id" json:"account_id"`

	// added by the generator so all types have created_at
	CreatedAt int64 `gorm:"int,column:created_at" json:"created_at"`
}
```
The field CreatedAt is added to all event types. For each event type, other than the `Event interface` functions, two other functions are generated:

- `TableName() string` used by the `gorm` library to set the name of the table. The original name provided in the json file is used for the table name.
- `NewRandom{{$EventName}}Event(*rand.Rand)` that returns a new instance with random values using the *rand.Rand that is provided to it.
  - Random functions inside implementation of these functions are provided by the caller within the same package. This behavior should be improved.

**The implementation of Retrieve and Store use `database/sql` because it result in better performance in compare to `gorm`**.

### Individual items
One `Migrate` function is generated that is in charge of updating the schema definitions on the database. This is done using the `gorm`'s Migrate function for each EventType. For the previous example, the implementation of this function is like this:
```go
// Migrate uses GORM to migrate the structs defined
// above. Calling this method multiple times is fine.
func Migrate(db *sql.DB, dsn string) error {
	var err error

	dialector := postgres.New(postgres.Config{
		DSN:                  dsn,
		DriverName:           "postgres",
		Conn:                 db,
		PreferSimpleProtocol: true,
	})

	gdb, err := gorm.Open(dialector, &gorm.Config{})
	if err != nil {
		return err
	}
	// migrating BurnCoinsEvent
	err = gdb.AutoMigrate(&BurnCoinsEvent{})
	if err != nil {
		return err
	}

  // auto-generated code for migrating other event types
	return nil
}
```

Two variables are also generated and exported by this code generation tool:

- `TypeMappingSource` stores the value from the environment variable that refer to type_mapping file other tools, such as monitoring system can exploit this.
- `RandomGeneratorConstructors` a map from event name (string) to the function that can generate a new random instance of that event type.